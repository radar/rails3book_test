<?xml version="1.0" encoding="UTF-8"?>
<chapter id="ch01_1">
  <title id="ch01_2">Ruby on Rails, the framework</title>

  <para id="ch01_3">
    Welcome aboard! It's great to have you with us on this journey throughout the world of Ruby on Rails. Ruby on Rails is known throughout the lands as a powerful web framework that helps developers rapidly build modern web applications. In particular, it provides lots of niceties that will help us in our quest to develop a fully-featured "real world" application and be happy doing it. Great developers are happy developers. It's not only Ruby on Rails itself that provides all these things, there's much more to the Rails world than at first glance, but not overwhelmingly too much though. And what a first glance! Oh you two haven't met? Well, time for some introductions then!
  </para>

  <section id="ch01_4">
    <title id="ch01_5">What is Ruby on Rails?</title>

    <para id="ch01_8">
      Ruby on Rails is a framework built on the Ruby language, hence the name "Ruby on Rails". The Ruby language was created back in 1993 by Yukihiro "Matz" Matsumuto of Japan. Ruby was released to the general public in 1995. Since then, it has earned both a reputation and an enthusiastic following for its clean design, elegant syntax, and wide selection of tools available in the standard library and via a package management system called <emphasis id="ch01_9">RubyGems</emphasis>. It also has a worldwide community and many active contributors constantly improving the language and the ecosystem around it.
    </para>

    <para id="ch01_10">
      Ruby on Rails was created during 2004 by David Heinemeier Hansson during the development of 37signals' flagship product: Basecamp. When Rails was needed for other 37signals projects, the team extracted the Rails code from Basecamp and crafted the beginnings of the Rails framework, releasing it as open source under the MIT license<footnote id="ch01_11"><para id="ch01_796">The MIT license: <uri id="ch01_797">http://en.wikipedia.org/wiki/MIT_License</uri></para></footnote>. Since that date, Ruby on Rails has quickly progressed to become one of the leading web development frameworks. This is in no small part due to the large community surrounding it who are constantly working on submitting patches to add new features or to fix existing bugs. Version 3 of this framework indicates yet another significant milestone in the project's history and introduces some new concepts, but won't leave those already familiar with the framework in the dark. It's this latest version of Rails that will be the primary focus for this book.
    </para>

    <section id="ch01_12">
      <title id="ch01_13">Benefits</title>

      <para id="ch01_14">
        Ruby on Rails allows for rapid development of applications by using a concept known as <emphasis id="ch01_15">convention over configuration</emphasis>. When you begin writing a Ruby on Rails application you run an application generator which creates a basic skeleton of directories and files for your application. These files and directories provide categorization for pieces of your code, such as the <filename id="ch01_240">app/models</filename> directory for containing files that interact with the database and <filename id="ch01_241">public/images</filename> directory for images. Because all of this is already there for you, you're not going to be spending your time configuring the way your application is laid out. It's done for you. 
      </para>

      <para id="ch01_16">
        How rapidly can you develop a Ruby on Rails application? Take the annual <emphasis id="ch01_17">Rails Rumble</emphasis> event. This event aims to bring together small teams of 1-4 developers around the world to develop Ruby on Rails<footnote id="ch01_18">and now other Ruby-based web frameworks, such as Sinatra</footnote> applications in a 48-hour period. Using Rails, these teams are able to deliver amazing web applications in just two days. <footnote id="ch01_19"><para id="ch01_798">To see an example of what came out of the 2009 Rails Rumble, take a look at their leaderboard: <uri id="ch01_799">http://r09.railsrumble.com/entries</uri></para></footnote> Another great example of rapid development of a Rails application would be the 20 minute blog screencast recorded by Yehuda Katz<footnote id="ch01_20"><para id="ch01_800">20 minute blog screencast: <uri id="ch01_801">http://vimeo.com/10732081</uri></para></footnote>. This screencast takes you from a "no application" state, to having a basic blogging and commenting system.
      </para>

      <para id="ch01_21">
        Ruby on Rails affords you a level of productivity that goes unheard of in other web frameworks. This is due to every Ruby on Rails application starting out the same way. Because the similarity between the applications is so close, the paradigm shift between different Rails applications is not tremendous. If and when you jump between Rails applications, you're not going to be learning how it all connects again. It's mostly the same.
      </para>
      
      
      <para id="ch01_24">
        The core features of Rails are a conglomerate of many different parts called Railties (when said aloud it rhymes with "bowties") such as <emphasis id="ch01_25">Active Record</emphasis>, <emphasis id="ch01_26">Active Support</emphasis>, <emphasis id="ch01_27">Action Mailer</emphasis> and <emphasis id="ch01_28">Action Pack</emphasis>.<footnote id="ch01_242">These Railties share the same version number as Rails, which means when you're using Rails 3.0, you're using the 3.0 version of the Railtie. This is helpful to know for when you upgrade Rails because the version number of the installed Railties should be the same as the version number of Rails.</footnote> These different Railties provide a large range of methods and classes that will help you develop your applications. They prevent you from performing boring, repetitive tasks -- such as coding how your application hooks into your database -- and lets you just get down to writing valuable code for your business from the word go.
      </para>

      <para id="ch01_83">
        Ever wished a way of writing automated tests for your web application was built in? Ruby on Rails has you covered by including part of Ruby's standard library called <emphasis id="ch01_84">Test::Unit</emphasis>. It is incredibly easy to write automated test code for your application, as you'll see all the way throughout this book. It really does save your bacon in the long term, and that's a fantastic thing. We touch on Test::Unit in the next chapter before moving onto RSpec and Cucumber, two other test frameworks that are more preferred than Test::Unit, and a little easier on the eyes too.
      </para>
      
      <para id="ch01_785">
        There's not just only testing frameworks that are available for your usage either. The Ruby community has produced several high-quality libraries (referred to as "RubyGems" or "gems" for short) which we can use in our day-to-day development with Ruby on Rails. Some of these provide additional features to the normal parts of Ruby on Rails, others provide ways to turn alternative markup languages such as Markdown and Textile into HTML. Usually, if you can think it there's a gem out there that will help you do it.
      </para>

      <para id="ch01_85">
        Noticing a common pattern yet? Probably. As you can see, Ruby on Rails (and the great community surrounding it) have provided code that performs the trivial application tasks for you, all the way from setting up the foundations of your application to handling the delivering of email. The time that all these libraries save you is immense! And because the code is open source, you don't have to go to a specific vendor to get support. Anybody who knows Ruby can help you if you're stuck.
      </para>
    </section>

    <section id="ch01_86">
       <title id="ch01_87">Common Terms</title>
       <para id="ch01_88">
         There are a few common Ruby on Rails terms you will hear quite a bit. This section explains what they mean and how they relate to a Rails application.
       </para>
       
         <formalpara id="ch01_89">
           <title id="ch01_90">MVC</title>
           <para id="ch01_91">
             <indexterm id="ch01_802">
               <primary id="ch01_803">MVC</primary>
             </indexterm>
             The <emphasis id="ch01_92">M</emphasis>odel-<emphasis id="ch01_93">V</emphasis>iew-<emphasis id="ch01_94">C</emphasis>ontroller (<emphasis id="ch01_95">MVC</emphasis>) paradigm is not unique to Ruby on Rails, but provides much of the core foundation for a Ruby on Rails application. This paradigm is designed to keep the logically different parts of the application separate, while providing a way for data to flow between them.
           </para>
           
           <para id="ch01_951">
             In applications that don't use MVC, the directory structure and how the different parts connect to each other is commonly left up to the original developer. Generally, this is a bad idea as different people have differing opinions on where things should go. In Rails, there's a specific directory structure that makes all developers conform to the same layout, putting all the parts of the application inside a <filename id="ch01_952">app</filename> directory as shown in Figure 1.x:
           </para>
           
           <para id="ch01_953">
             <figure id="ch01_954">
               <title id="ch01_955">Figure 1.1 The app directory</title>
               <mediaobject id="ch01_956">
                 <imageobject id="ch01_957">
                   <imagedata fileref="ch01/app.jpg" id="ch01_958"/>
                 </imageobject>
               </mediaobject>
             </figure>
           </para>
           
           
           <para id="ch01_959">
             There's three main directories in this application, <filename id="ch01_960">models</filename>, <filename id="ch01_961">controllers</filename> and <filename id="ch01_962">views</filename>.
           </para>

           <para id="ch01_96">
             Models are where the <emphasis id="ch01_97">domain logic</emphasis> -- how the records in your database are retrieved -- is kept. In the case of Rails applications, models define the code that interacts with the database's tables to retrieve and set information in them. Domain logic also means things such as validations or particular actions to perform on the data.
           </para>

           <para id="ch01_98">
             Controllers interact with the models to gather information to send to the view. They do this by calling methods on the model classes which can return single objects representing rows in our database, or collections (arrays) of these objects. Controllers will then take these objects and make them available to the view through instance variables. 
           </para>

           <para id="ch01_99">
             Views display the information gathered by the controller, by referencing the instance variables set there, in a user-friendly manner. In Ruby on Rails, this is done by default with a templating language known as <emphasis id="ch01_246">E</emphasis>mbedded <emphasis id="ch01_247">R</emphasis>u<emphasis id="ch01_248">b</emphasis>y (<emphasis id="ch01_249">ERB</emphasis>). ERB allows us to embed Ruby (hence the name) into any kind of file we wish. This template is then pre-processed on the server side into the output which is shown to the user.
           </para>
           
           <para id="ch01_963">
             The <filename id="ch01_964">assets</filename>, <filename id="ch01_965">helpers</filename> and <filename id="ch01_966">mailers</filename> directories aren't part of the MVC paradigm, but they are important parts of Rails.
           </para>
           
           <para id="ch01_967">
             The <filename id="ch01_968">assets</filename> directory is for the static assets of the application, such as JavaScript files, images and CSS for making the application look pretty. We look more in-depth at this in Chapter 3.
           </para>
           
           <para id="ch01_969">
             The <filename id="ch01_970">helpers</filename> directory is a place to put Ruby code (specifically, modules) that provide helper methods for just the views. These helper methods can help with complex formatting that would otherwise be messy in the view or is used in more than one place.
           </para>
           
           <para id="ch01_971">
             Finally, <filename id="ch01_972">mailers</filename> is a home for the classes of our application that deal with sending out email. In previous versions of Rails, these were grouped with models but have since been given their own home. We look at these in Chapter 11.
           </para>
             
         </formalpara>

         <formalpara id="ch01_250">
           <title id="ch01_251">REST</title>
             <para id="ch01_106">
               <indexterm id="ch01_804">
                 <primary id="ch01_805">REST</primary>
               </indexterm>
               MVC in Rails is aided by REST, a routing paradigm. <emphasis id="ch01_252">Re</emphasis>presentational <emphasis id="ch01_253">S</emphasis>tate <emphasis id="ch01_254">T</emphasis>ransfer (<emphasis id="ch01_110">REST</emphasis>) is the convention for <emphasis id="ch01_111">routing</emphasis> in Rails. When something adheres to this convention it is said to be <emphasis id="ch01_255">RESTful</emphasis>. Routing in Rails refers to how requests are routed within the application itself. We will benefit greatly by adhering to these conventions, as Rails provides a lot of functionality around RESTful routing for free, such as determining where a form can, or will, send to.
             </para>
         </formalpara>
     </section>

     <section id="ch01_112">
       <title id="ch01_113">Rails in the wild</title>
       <para id="ch01_114">
         A question sometimes asked by people new to Rails is: "Is Rails ready?" Of course! The evidence is stacked mightily in Rails' favor with websites such as Twitter, Yellow Pages and of course Basecamp serving millions and millions of page requests daily <footnote id="ch01_115"><para id="ch01_806">Some of the more well-known applications that run on Ruby on Rails can be found at <uri id="ch01_807">http://rubyonrails.org/applications</uri>.</para></footnote>.
       </para>

       <para id="ch01_116">
         If any site is a testament to the power of Ruby on Rails, Twitter would be it. Even though Twitter suffered from scaling problems back in 2008 (due to its massive growth, and other technological problems, <emphasis id="ch01_117">not</emphasis> due to Rails) it is now the 11<superscript id="ch01_118">th</superscript> most popular website according to Alexa and is exceptionally stable.
       </para>

       <para id="ch01_119">
         Another well-known site that runs Ruby on Rails is GitHub, a hosting service for Git repositories. This site was launched in February 2008 and is now the leading Git web-hosting site online. GitHub's massive growth was in part due to the Ruby on Rails community quickly adopting it as their de facto repository hosting site. Now GitHub is home to over a million repositories for just about every single programming language on the planet. It's not exclusive to programming languages either; if it can go in a Git repository it can go on GitHub. As a matter of fact, this book is kept on GitHub!
       </para>

       <para id="ch01_120">
         Now that we've seen what other people have accomplished with this framework, let's dive into creating an application for ourselves.
       </para>
     </section>
  </section>


  <section id="ch01_121">
    <title id="ch01_122">Developing your first application</title>

    <para id="ch01_123">
      We've covered the theory behind Rails, and showed how quickly and easily you can develop an application. Now it's your turn to get an application going. 
    </para>
    
    <section id="ch01_270">
      <title id="ch01_271">Installing Rails</title>
      
      <para id="ch01_272">
        In order to do this though, you must have these three things installed:
      </para>

      <itemizedlist id="ch01_124">
        <listitem id="ch01_125"><para id="ch01_126">Ruby</para></listitem>
        <listitem id="ch01_127"><para id="ch01_128">RubyGems</para></listitem>
        <listitem id="ch01_129"><para id="ch01_130">Rails</para></listitem>
      </itemizedlist>

      <para id="ch01_131">
        If you're on a UNIX-based system (Linux or Mac) we recommend that you use RVM (http://rvm.beginrescueend.com) to install Ruby and Rubygems. It is the preferred solution of the community as it just works so simply. Installing from a package management system such as Ubuntu's Aptitude has been known to be broken<footnote id="ch01_808"><para id="ch01_809">Broken Ubuntu Ruby explained here: <uri id="ch01_810">http://ryanbigg.com/2010/12/ubuntu-ruby-rvm-rails-and-you/</uri></para></footnote> After installing RVM you will need to run this command to install a 1.9.2 version of Ruby:
      </para>
      
      <informalexample id="ch01_811">
        <programlisting>
rvm install 1.9.2
        </programlisting>
      </informalexample>
      
      <para id="ch01_813">
        To use this version of Ruby we would need to use the <command id="ch01_814">rvm use 1.9.2</command> every time we wished to use it, or set up an <filename id="ch01_815">.rvmrc</filename> file in the root of our project, which is explained on the RVM site in great detail. Alternatively, we could set this version of Ruby as the default using <command id="ch01_816">rvm use --default 1.9.2</command>, using <command id="ch01_817">rvm use system</command> if we ever wanted to swap back to the system-provided Ruby install, if there is one.
      </para>
      
      <para id="ch01_818">
        If you're on Windows, you will not be able to use RVM and you will not be able to use a 1.9.* version of Ruby, but that's ok. Rails 3 will still work with Ruby 1.8 versions of Rails too. The Ruby-lang site (http://ruby-lang.org) has a Ruby 1.8.7-p334 Binary which we recommend using or alternatively the Rails installer (http://railsinstaller.org) from Engine Yard is also good. 
      </para>
    
      <para id="ch01_139">
         Next, we will need to install the rails gem. The following command will not only install Rails, but its dependencies too.
      </para>
    
      <informalexample id="ch01_140">
        <programlisting>
gem install rails --pre
        </programlisting>
      </informalexample>
    </section>
    
    <section id="ch01_273">
      <title id="ch01_274">Generating an application</title>

      <para id="ch01_142">
        Now with Rails installed, to generate an application we run the <command id="ch01_143">rails</command> command and pass it the <command id="ch01_144">new</command> argument and the name of the application we want to generate: <emphasis id="ch01_145">things_i_bought</emphasis>. When we run this command it will create a new directory called <code id="ch01_795">things_i_bought</code> which is where all our application's code will go. We can call our application anything we wish, but it can't be given the same name as a reserved word in Rails <footnote id="ch01_259">http://wiki.rubyonrails.org/rails/pages/reservedwords</footnote>. For example, we wouldn't call our application "rails" because this defines a Rails <emphasis id="ch01_146">constant</emphasis> which is already defined internally to Rails itself, and the two constants will clash.
      </para>
    
      <para id="ch01_109">
        The application that we're going to generate will be an application where we'll be able to record purchases we have made. We can generate this application by using this command.
      </para>

      <informalexample id="ch01_147">
        <programlisting>
rails new things_i_bought
        </programlisting>
      </informalexample>

    	<indexterm id="ch01_821">
    	  <primary id="ch01_822">rails new command</primary>
    	</indexterm>

      <para id="ch01_149">
        The output from this command may seem a bit overwhelming at first, but rest assured: it's for our own good. All of the directories and files that were generated here provide the building blocks for our application and we'll get to know each of them as we progress. For now, let's just get rolling and learn by doing, which is the best way of learning.
      </para>
    </section>
    
    <section id="ch01_275">
      <title id="ch01_276">Starting the application</title>

      <para id="ch01_150">
        To get the server running we must first change into the newly created application's directory and then run these commands to start the application server:
      </para>

      <informalexample id="ch01_151">
        <programlisting>
cd things_i_bought
bundle install --binstubs
rails server
        </programlisting>
      </informalexample>

      <indexterm id="ch01_824">
        <primary id="ch01_825">bundle install</primary>
      </indexterm>

      <indexterm id="ch01_826">
        <primary id="ch01_827">rails server</primary>
      </indexterm>
      
      <para id="ch01_748">
        The <command id="ch01_749">bundle install</command> command here will install all the gems required for our application, including the executable files for them in the <filename id="ch01_977">bin</filename> directory for our application, which is what the <code id="ch01_978">--binstubs</code> option does. This is explained in further detail in Chapter 3.
      </para>

      <para id="ch01_153">
        This will start up a web server on your local address on port 3000 using a Ruby standard library web server known as WEBrick. To connect to this server, go to <uri id="ch01_154">http://localhost:3000</uri> in your favorite browser. Now, we'll see the "Welcome aboard" page which is so famous to Rails.
      </para>

      <figure id="ch01_155">
        <title id="ch01_156">Welcome aboard!</title>
        <mediaobject id="ch01_157">
          <imageobject id="ch01_158">
            <imagedata fileref="ch01/welcome_aboard.png" id="ch01_159"/>
          </imageobject>
        </mediaobject>
      </figure>


      <para id="ch01_160">
        If we click "About your application's environment" we'll be told things like our Ruby, RubyGems, Ruby on Rails, Rack versions, and other environmental data. One of the things to note here is that the output for "Environment" is "development". There are three environments Rails provides for running our application: development, test and production. How our application functions can be dependent of the environment it is running in. For example, in the development environment classes are not cached. This means that if we make a change to a class when running an application in development mode we do not need to restart the server, but the same change in the production environment means we would.
      </para>
    </section>
    <section id="ch01_277">
      <title id="ch01_278">Scaffolding</title>
      <indexterm id="ch01_828">
        <primary id="ch01_829">scaffold generator</primary>
      </indexterm>
      <para id="ch01_161">
        To get started with this Rails application we'll generate a <emphasis id="ch01_279">scaffold</emphasis>. Scaffolds in Rails provide us with a lot of basic functionality, but are generally not used for full-scale development as we may want something more custom. If this was the case, we wouldn't use scaffolding and we'd build it ourselves. But this time we want to see what Rails can do, so let's generate a scaffold by running this command:
      </para>
    
      <informalexample id="ch01_280">
        <programlisting>
rails generate scaffold purchase name:string cost:float
        </programlisting>
      </informalexample>

      <indexterm id="ch01_831"><primary id="ch01_832">rails generate</primary></indexterm>
    
      <para id="ch01_282">
        When we used the <command id="ch01_168">rails</command> command before, it generated an entire Rails application for us. We can use this command inside of an application to generate a specific part of the application for us. The way to do this is to pass the <command id="ch01_169">generate</command> argument to the <command id="ch01_750">rails</command> command, followed by what it is we want to generate. 
      </para>
    
      <para id="ch01_283">
        The <command id="ch01_284">scaffold</command> command generates a model, controller and views for us based on the name passed after "scaffold" in this command. These are the three important parts we need for our purchase tracking. The model provides a way for us to interact with a database. The controller interacts with the model to retrieve and format its information and defines different actions to perform on this data. The views display the information from the controller in a neat format for us.
      </para>
      
      <para id="ch01_751">
        Everything after the name for the scaffold are the fields for the database table, as well as the <emphasis id="ch01_752">attributes</emphasis> for the objects of this scaffold. Here we tell Rails that the table for our purchase scaffold will contain a <code id="ch01_753">name</code> and <code id="ch01_754">cost</code> field which are a string and a float<footnote id="ch01_755"><para id="ch01_756">Usually you wouldn't use a float for storing monetary amounts because it can lead to incorrect rounding errors. Generally, you would store the amount in cents as an integer and then do the conversion back to a full dollar amount. In this example we'll be using float as it's easier for us to not have to define the conversion at this moment.</para></footnote> To create this table the scaffold generator generates what's known as a <emphasis id="ch01_757">migration</emphasis>. Let's have a look at what migrations are right now.
      </para>
      
    </section>
    <section id="ch01_288">
      <title id="ch01_289">Migrations</title>
      <indexterm id="ch01_833">
        <primary id="ch01_834">Migrations</primary>
      </indexterm>
      <para id="ch01_290">
        Migrations are used in Rails as a form of version control for the database, providing a way to implement incremental changes to the schema of the database. Each migration is timestamped right down to the second which provides you (and anybody else developing the application with you) an accurate timeline of your database. When two developers are working on separate features of an application and both generate a new migration, this timestamp will stop them from clashing. Let's open the only file in <filename id="ch01_291">db/migrate</filename> now and see what it does. Its contents are shown in Listing 1.x.
      </para>
    
      <example id="ch01_292">
        <title id="ch01_293">db/migrate/[date]_create_purchases.rb</title>
        <programlisting>
<![CDATA[class CreatePurchases < ActiveRecord::Migration
  def self.up
    create_table :purchases do |t|
      t.string :name
      t.float :cost

      t.timestamps
    end
  end

  def self.down
    drop_table :purchases
  end
end]]>
        </programlisting>
      </example>
    
      <para id="ch01_295">
        Migrations are Ruby classes that inherit from <code id="ch01_296">ActiveRecord::Migration</code>. Inside the class, there are two class methods defined: <code id="ch01_298">up</code> and <code id="ch01_299">down</code>. Inside the <code id="ch01_300">up</code> method is the code we want to be run when we run the migration, and inside the <code id="ch01_301">down</code> method is the code that will run when we roll the migration back.
      </para>
      
    
      <para id="ch01_302">
        Inside both of these methods we use database-agnostic commands to create and drop a table. In the <code id="ch01_303">up</code> method, we create a table and we specify the fields we want in that table by calling methods on the <code id="ch01_304">t</code> block variable. The <code id="ch01_305">string</code> and <code id="ch01_306">float</code> methods will create fields of those particular types on any database system that's compatible with Rails<footnote id="ch01_307">So far: MySQL, PostgreSQL, SQLite3, Oracle, Frontbase and IBM DB</footnote>. We specified these fields when we used the <command id="ch01_308">scaffold</command> command. The <code id="ch01_309">timestamps</code> method is special; it creates two fields called <code id="ch01_310">created_at</code> and <code id="ch01_311">updated_at</code> which will have their values set when records are created and updated automatically by Rails.
      </para>
    
      <para id="ch01_312">
        To run the migration we type this command into the console:
      </para>
      
      <informalexample id="ch01_758">
        <programlisting>
bin/rake db:migrate
        </programlisting>
      </informalexample>
      
      <para id="ch01_760">
        This command will run the <code id="ch01_314">self.up</code> part of this migration. Because this is our first time running migrations in our Rails application, and because we're using an SQLite3 database, Rails will first create the database in a new file at <filename id="ch01_761">db/development.sqlite3</filename> and then create the <code id="ch01_762">purchases</code> table inside that. When we run <code id="ch01_763">bin/rake db:migrate</code> it doesn't just run the <code id="ch01_764">self.up</code> method from the latest migration, but runs any migration that hasn't yet been run allowing you to run multiple migrations sequentially.
      </para>
      
      <para id="ch01_765">
        Our application is, by default, already set up to talk to this new database so we don't need to change anything to make it to do that. If we ever wanted to roll this migration back we would use <command id="ch01_317">bin/rake db:rollback</command>, which rolls back the latest migration by running the <code id="ch01_766">self.down</code> method of the migration.<footnote id="ch01_767"><para id="ch01_768">If we wanted to rollback more than one migration we would use the <command id="ch01_769">bin/rake db:rollback STEP=3</command> command which would roll back the latest 3 migrations.</para></footnote>
      </para>
      
      <para id="ch01_770">
        Rails will keep track of the last migration that was ran by storing it using this line in the <filename id="ch01_771">db/schema.rb</filename> file:
      </para>
      
      <informalexample id="ch01_772">
        <programlisting>
<![CDATA[ActiveRecord::Schema.define(:version => [timestamp]) do]]>
        </programlisting>
      </informalexample>
      
      <para id="ch01_774">
        This version should match the prefix of the migration that we just created<footnote id="ch01_775"><para id="ch01_776">where <code id="ch01_777">[timestamp]</code> in the above example is an actual timestamp formatted like <code id="ch01_778">YYYYmmddHHMMSS</code></para></footnote>, and Rails will use this value to know what migration it's up to. The remaining content of this file shows us the combined state of all the migrations up to this point. This file can be used to restore the last-known state of our database if we run the <command id="ch01_779">bin/rake db:schema:load</command> command.
      </para>
      
      <para id="ch01_780">
        With our database set up with a <code id="ch01_781">purchases</code> table in it, let's look at how we can add rows to it through our application
      </para>
    </section>
    
    <section id="ch01_318">
      <title id="ch01_319"><![CDATA[Viewing & creating purchases]]></title>
    
      <para id="ch01_320">
        Let's start our browser now and go to http://localhost:3000/purchases. We will see the scaffolded screen for purchases, like what's shown in Listing 1.x.
      </para>
    
      <figure id="ch01_321">
        <title id="ch01_322">Purchases</title>
        <mediaobject id="ch01_323">
          <imageobject id="ch01_324">
            <imagedata fileref="ch01/purchases.png" id="ch01_325"/>
          </imageobject>
        </mediaobject>
      </figure>
    
      <para id="ch01_326">
        At the moment we don't have any purchases listed, so let's add a new purchase by clicking "New Purchase".
      </para>
    
      <para id="ch01_327">
      
       Here we see two inputs for the fields we generated.
      </para>
    
      <figure id="ch01_328">
        <title id="ch01_329">A new purchase</title>
        <mediaobject id="ch01_330">
          <imageobject id="ch01_331">
            <imagedata fileref="ch01/new_purchase.png" id="ch01_332"/>
          </imageobject>
        </mediaobject>
      </figure>
    
      <para id="ch01_333">
        This page is the result of <code id="ch01_334">new</code> action from the <classname id="ch01_782">PurchasesController</classname> controller. What we see on the page comes from the view located at <filename id="ch01_335">app/views/purchases/new.html.erb</filename> and it looks like Listing 1.x.
      </para>
    
      <example id="ch01_336">
        <title id="ch01_337"/>
        <programlisting>
<![CDATA[<h1>New purchase</h1>

<%= render 'form' %>

<%= link_to 'Back', purchases_path %>]]>
        </programlisting>
      </example>
    
      <para id="ch01_339">
        This is an ERB (Embedded Ruby) file. These files allow you to mix HTML and Ruby code to generate dynamic pages. The <code id="ch01_340"><![CDATA[<%=]]></code> beginning of an ERB tag indicates that the result of the code inside the tag will be output to the page. If we only wanted the code to be evaluated and not output, we would use the <code id="ch01_341"><![CDATA[<%]]></code> tag, like this:
      </para>
      
      <informalexample id="ch01_741">
        <programlisting>
<![CDATA[<% some_variable = "foo" %>]]>
        </programlisting>
      </informalexample>
      
      <para id="ch01_743">
        If we were to use <![CDATA[<%= some_variable = "foo" %>]]> here, the <code id="ch01_840">some_variable</code> variale would be set and the value output to the screen. By using <code id="ch01_841"><![CDATA[<%]]></code>, the Ruby code is evaluated but not output.
      </para>
    
      <para id="ch01_342">
         The <code id="ch01_343">render</code> method here when passed a string -- such as in this example -- will render a <emphasis id="ch01_344">partial</emphasis>, while the <code id="ch01_842">link_to</code> method will generate a link with the text of the first argument "Back" and with a <code id="ch01_843">href</code> attribute specified by the second argument (<code id="ch01_844">purchases_path</code>), which will be simply <code id="ch01_845">/purchases</code>.
         <indexterm id="ch01_846">
           <primary id="ch01_847">link_to</primary>
         </indexterm>
         <indexterm id="ch01_848">
           <primary id="ch01_849">render, partial</primary>
         </indexterm>
      </para>
      
      <para id="ch01_850">
        This particular partial is at <filename id="ch01_345">app/views/purchases/_form.html.erb</filename> and the first half of it looks like Listing 1.x.
      </para>
    
      <example id="ch01_346">
        <title id="ch01_347">app/views/purchases/_form.html.erb</title>
        <programlisting>
<![CDATA[<%= form_for(@purchase) do |f| %>
  <% if @purchase.errors.any? %>
    <div id="error_explanation">
      <h2><%= pluralize(@purchase.errors.count, "error") %> prohibited this 
        purchase from being saved:</h2>

      <ul>
      <% @purchase.errors.full_messages.each do |msg| %>
        <li><%= msg %></li>
      <% end %>
      </ul>
    </div>
  <% end %>]]>
        </programlisting>
      </example>
    
      <para id="ch01_349">
        This half is responsible for defining the form by using the <code id="ch01_350">form_for</code><indexterm id="ch01_852">
          <primary id="ch01_853">form_for</primary></indexterm>helper. The <code id="ch01_744">form_for</code> method is passed one argument -- an instance variable called <code id="ch01_351">@purchase</code> -- and with <code id="ch01_352">@purchase</code> it generates a form. This variable comes from the <code id="ch01_353">PurchasesController</code>'s <code id="ch01_354">new</code> action which is shown in Listing 1.x.
      </para>
    
      <example id="ch01_355">
        <title id="ch01_356">app/controllers/purchases_controller.rb</title>
        <programlisting>
<![CDATA[def new
  @purchase = Purchase.new

  respond_to do |format|
    format.html # new.html.erb
    format.xml  { render :xml => @purchase }
  end
end]]>
        </programlisting>
      </example>
    
      <para id="ch01_358">
        The first line in this action sets up a new <code id="ch01_855">@purchase</code> variable by calling the <code id="ch01_856">new</code> method on the <classname id="ch01_857">Product</classname> model, which initializes a new object of this model.<indexterm id="ch01_858"><primary id="ch01_859">new, ActiveRecord::Base</primary></indexterm> The variable is then passed through to the view automatically by Rails.
      </para>
    
      <para id="ch01_361">
        Next, in the controller there is the <code id="ch01_362">respond_to</code> <indexterm id="ch01_860"><primary id="ch01_861">respond_to</primary></indexterm> method which defines what formats this action responds to. Here, our controller responds to the <code id="ch01_363">html</code> and <code id="ch01_364">xml</code> formats. The <code id="ch01_365">html</code> method here isn't given a block and so will render the template from <filename id="ch01_366">app/views/purchases/new.html.erb</filename>, whereas the <code id="ch01_367">xml</code> method which is given a block, will execute the code inside the block and return an XML version of the <code id="ch01_368">@purchase</code> object. We'll be looking at what the <code id="ch01_783">html</code> response does from here on in as that is the default format requested.
      </para>
      
      <para id="ch01_369">
        So far, all of this functionality is provided by Rails. We've coded nothing ourselves. With the <command id="ch01_370">scaffold</command> generator we get an awful lot for free.
      </para>
    
      <para id="ch01_371">
        Going back to the view, the block for the <code id="ch01_862">form_for</code> is defined in between its <code id="ch01_372">do</code> and the <code id="ch01_373"><![CDATA[<% end %>]]></code> at the end of the file. Inside this block, we check the <code id="ch01_374">@purchase</code> object for any errors by using the <code id="ch01_863">@purchase.errors.any?</code><indexterm id="ch01_864">
          <primary id="ch01_865">errors, ActiveRecord::Base</primary>
        </indexterm> method. These errors will come from the model if the object did not pass the validation requirements set in the model. If there are any errors, they would be rendered by the content inside this <code id="ch01_866">if</code> statement. Validation is a concept we'll cover shortly.
      </para>
    
      <para id="ch01_376">
        The second half of this partial looks like Listing 1.x.
      </para>
    
      <example id="ch01_377">
        <title id="ch01_378">app/views/purchases/_form.html.erb</title>
        <programlisting>
  <![CDATA[<div class="field">
    <%= f.label :name %><br />
    <%= f.text_field :name %>
  </div>
  <div class="field">
    <%= f.label :cost %><br />
    <%= f.text_field :cost %>
  </div>
  <div class="actions">
    <%= f.submit %>
  </div>
<% end %>]]>
        </programlisting>
      </example>
    
      <para id="ch01_380">
        Here, the <code id="ch01_381">f</code> object from the <code id="ch01_382">form_for</code> block is used to define labels and fields for our form. At the end of this partial, the <code id="ch01_383">submit</code> method provides us with a dynamic submit button.
      </para>
    
      <para id="ch01_384">
        Let's fill in this form now and press the submit button. We should now see something similar to Figure 1.x.
      </para>
      
      <figure id="ch01_385">
        <title id="ch01_386">Our first purchase</title>
        <mediaobject id="ch01_387">
          <imageobject id="ch01_388">
            <imagedata fileref="ch01/show_purchase.png" id="ch01_389"/>
          </imageobject>
        </mediaobject>
      </figure>
        
      <para id="ch01_390">
        What we are seeing here is the result of our posting; a successful creation of a <classname id="ch01_391">Purchase</classname>. Let's see how it got there. This submit button posts the data from the form to the <code id="ch01_392">create</code> action which looks like Listing 1.x.
      </para>
      
      <example id="ch01_393">
        <title id="ch01_394">app/controllers/purchases_controller.rb</title>
        <programlisting>
<![CDATA[def create
  @purchase = Purchase.new(params[:purchase])

  respond_to do |format|
    if @purchase.save
      format.html { redirect_to(@purchase, :notice => 'Purchase was successfully created.') }
      format.xml  { render :xml => @purchase, :status => :created, :location => @purchase }
    else
      format.html { render :action => "new" }
      format.xml  { render :xml => @purchase.errors, :status => :unprocessable_entity }
    end
  end
end]]>
        </programlisting>
      </example>
      
      <para id="ch01_396">
        Here, we use the <code id="ch01_397">Purchase.new</code> we first saw used in the <code id="ch01_398">new</code> action. But, this time we pass it an argument of <code id="ch01_399">params[:purchase]</code>. <code id="ch01_400">params</code><indexterm id="ch01_869"><primary id="ch01_870">params</primary></indexterm> (short for "parameters") is a method which returns the parameters sent from our form in a <classname id="ch01_740">Hash</classname>-like object. By passing in this params hash into <code id="ch01_405">new</code>, Rails will set the <emphasis id="ch01_406">attributes</emphasis><footnote id="ch01_407">The Rails word for "fields"</footnote> to the values from the form. 
      </para>
      
      <para id="ch01_408">
        Inside the <code id="ch01_409">respond_to</code> there's an <code id="ch01_410">if</code> statement which calls <code id="ch01_411">@purchase.save</code><indexterm id="ch01_871"><primary id="ch01_872">save, ActiveRecord::Base</primary></indexterm>. This method will <emphasis id="ch01_413">validate</emphasis> the record, and if it's valid, then it will save the record to the database and return <code id="ch01_414">true</code>.
      </para>
      
      <para id="ch01_873">
        If this is the case, then the action will respond by redirecting to the new <code id="ch01_415">@purchase</code> object by using the <code id="ch01_416">redirect_to</code> <indexterm id="ch01_874"><primary id="ch01_875">redirect_to</primary></indexterm> method which takes either a path or an object which it'll turn into a path (as seen in this example). The <code id="ch01_417">redirect_to</code> method interprets what the <code id="ch01_418">@purchase</code> object is and will determine the path required is <code id="ch01_876">purchase_path</code> because it's an object of the <classname id="ch01_877">Purchase</classname> model. This path will take us to the <code id="ch01_419">show</code> action for this controller. The <code id="ch01_420">:notice</code> option passed to the <code id="ch01_878">redirect_to</code> sets up a <emphasis id="ch01_421">flash message</emphasis>.<indexterm id="ch01_879">
          <primary id="ch01_880">redirect_to, :notice option</primary>
        </indexterm> A flash message is a message that can be displayed on the next request. This is the green text at the top of the previous figure, Figure 1.x.
      </para>
      
      <para id="ch01_422">
        So, we've seen what happens when the purchase is valid, but what happens when it's invalid? Well, it uses the <code id="ch01_571">render</code> method to show us the <code id="ch01_572">new</code> action's template again. We should note here that this doesn't call the <code id="ch01_573">new</code> action / method again<footnote id="ch01_574"><para id="ch01_666">To do that, we'd call <code id="ch01_575">redirect_to new_purchase_path</code>, but that wouldn't persist the state of the <code id="ch01_784">@purchase</code> object to this new request without some seriously bad hackery. By re-rendering the template, we can display information about the object if the object is invalid.</para></footnote> but rather only renders the template.
      </para>
      
      <para id="ch01_576">
        We can make the creation of the <code id="ch01_577">@purchase</code> object fail by adding a validation. Let's do that now.
      </para>
    </section>
  
    <section id="ch01_423">
      <title id="ch01_424">Validations</title>
      
      <para id="ch01_425">
        We can add validations to our model to ensure that the data conforms to certain rules, or, that data for a certain field has to be present, or a number we enter has to be above a certain other number. We're going to write our first code for this application and implement both of these things now.
      </para>
      
      <para id="ch01_426">
        Let's open up our <classname id="ch01_427">Purchase</classname> model and change the whole file to what's shown in Listing 1.x.
      </para>
      
      <example id="ch01_428">
        <title id="ch01_429">app/models/purchase.rb</title>
        <programlisting>
<![CDATA[class Purchase < ActiveRecord::Base
  validates_presence_of :name
  validates_numericality_of :cost, :greater_than => 0
end]]>
        </programlisting>
      </example>
      
      <para id="ch01_431">
        Here we use the <code id="ch01_432">validates_presence_of</code><indexterm id="ch01_882"><primary id="ch01_883">validates_presence_of</primary></indexterm>method to define a validation that does what it says on the box: validates that the field has a value. The other validation method, <code id="ch01_884">validates_numericality_of</code><indexterm id="ch01_885"><primary id="ch01_886">validates_numericality_of</primary></indexterm> we are using does more than what it initially claims: it validates that the <code id="ch01_667">cost</code> attribute is a number and that it is greater than 0.
      </para>
            
      <para id="ch01_438">
        Let's test out these validations by going back to http://localhost:3000/purchases, clicking "New Purchase" and clicking "Create Purchase" right away. We should see the errors, as shown in Figure 1.x.
      </para>

      <figure id="ch01_439">
        <title id="ch01_440">Errors on purchase</title>
        <mediaobject id="ch01_441">
          <imageobject id="ch01_442">
            <imagedata fileref="ch01/purchase_errors.png" id="ch01_443"/>
          </imageobject>
        </mediaobject>
      </figure>
      
      
      <para id="ch01_444">
        Great! Here, we're told that name can't be blank and that the value we entered for cost isn't a number. Let's see what happens now if we enter <code id="ch01_445">foo</code> for the name field, <code id="ch01_446">-100</code> for the cost fields, and press "Create Purchase". We should get a different error for the cost field now, as shown in Figure 1.x.
      </para>
      
      <figure id="ch01_447">
        <title id="ch01_448">Cost must be greater than 0</title>
        <mediaobject id="ch01_449">
          <imageobject id="ch01_450">
            <imagedata fileref="ch01/purchase_errors_2.png" id="ch01_451"/>
          </imageobject>
        </mediaobject>
      </figure>
      
      <para id="ch01_452">
        Good to see! Both of our validations are working now. When we change cost to <code id="ch01_453">100</code> and press "Create Purchase" then it should be considered valid by the validations and take us to the <code id="ch01_454">show</code> action. Let's look at what this particular action does now.
      </para>
    </section>
    
    <section id="ch01_455">
      <title id="ch01_456">Showing off</title>
      <para id="ch01_457">
        So, we've seen that this action displays the content such as shown in Figure 1.x.
      </para>
      
      <figure id="ch01_458">
        <title id="ch01_459">A single purchase</title>
        <mediaobject id="ch01_460">
          <imageobject id="ch01_461">
            <imagedata fileref="ch01/purchases_show_with_url.png" id="ch01_462"/>
          </imageobject>
        </mediaobject>
      </figure>
      
      <para id="ch01_463">
        The number at the end of the URL here is the unique numerical id for this particular purchase. But what does this mean? Let's look at the view for this <code id="ch01_464">show</code> action now, as shown in Listing 1.x.
      </para>
      
      <example id="ch01_465">
        <title id="ch01_466">app/views/purchases/show.html.erb</title>
        <programlisting>
<![CDATA[<p id="notice"><%= notice %></p>

<p>
  <b>Name:</b>
  <%= @purchase.name %>
</p>

<p>
  <b>Cost:</b>
  <%= @purchase.cost %>
</p>


<%= link_to 'Edit', edit_purchase_path(@purchase) %> |
<%= link_to 'Back', purchases_path %>]]>
        </programlisting>
      </example>
      
      <para id="ch01_468">
        On the first line there's the <code id="ch01_469">notice</code><indexterm id="ch01_888"><primary id="ch01_889">notice</primary></indexterm> method which will display the <code id="ch01_470">notice</code> set on the <code id="ch01_471">redirect_to</code> from the <code id="ch01_472">create</code> action. After that, value for our fields are displayed in <code id="ch01_473">p</code> tags by simply calling them as methods on our <code id="ch01_474">@purchase</code> object. This object is defined in our <classname id="ch01_475">PurchasesController</classname>'s <code id="ch01_476">show</code> action, as shown in Listing 1.x.
      </para>
      
      <example id="ch01_477">
        <title id="ch01_478">app/controllers/purchases_controller.rb</title>
        <programlisting>
def show
  @purchase = Purchase.find(params[:id])

  ...
end
        </programlisting>
      </example>
      
      <para id="ch01_480">
        Here, the <code id="ch01_481">find</code><indexterm id="ch01_891">
          <primary id="ch01_892">find, ActiveRecord::Base</primary></indexterm> method of the <classname id="ch01_482">Purchase</classname> class is used to find the record with the id of <code id="ch01_578">params[:id]</code> and instantiate a new <classname id="ch01_579">Purchase</classname> object from it with <code id="ch01_580">params[:id]</code> as the number on the end of the URL.
      </para>
      
      <para id="ch01_484">
        Going back to the view (<filename id="ch01_485">app/views/purchases/show.html.erb</filename>) now and at the end of this file there is <code id="ch01_486">link_to</code> which will generate a link, using the first argument as the text for it and the second argument as the <code id="ch01_487">href</code> for that URL. The second argument for <code id="ch01_488">link_to</code> is a method itself: <code id="ch01_489">edit_purchase_path</code>. This method is provided by a method call in <filename id="ch01_490">config/routes.rb</filename>, which we'll now look at.
      </para>    
    </section>
    
    <section id="ch01_491">
      <title id="ch01_492">Routing</title>
      <para id="ch01_493">
        The <filename id="ch01_494">config/routes.rb</filename> file of every Rails application is where the application routes are defined in a succint Ruby syntax. The methods used in this file define the pathways from requests to controllers. If we look in our <filename id="ch01_495">config/routes.rb</filename> while ignoring the commented out lines for now, we'll see what's shown in Listing 1.x.<indexterm id="ch01_893">
          <primary id="ch01_894">config/routes.rb</primary>
        </indexterm>
      </para>
      
      <example id="ch01_496">
        <title id="ch01_497">config/routes.rb</title>
        <programlisting>
ThingsIBought::Application.routes.draw do
  resources :purchases
end
        </programlisting>
      </example>
      
      <indexterm id="ch01_896"><primary id="ch01_897">Routing, resources method</primary></indexterm>
      
      <para id="ch01_499">
        Inside the block for the <code id="ch01_500">draw</code> method, there's the <code id="ch01_501">resources</code> method. Collections of similar objects in Rails are referred to as <emphasis id="ch01_502">resources</emphasis>. This method defines the routes and routing helpers (such as the <code id="ch01_503">edit_purchase_path</code> method) to our purchases resources for us. Look at Table 1.x for a list of the helpers and the routes they correspond to.
      </para>
      
      <indexterm id="ch01_898">
        <primary id="ch01_899">Routing helpers</primary>
      </indexterm>
      <table id="ch01_504">
        <title id="ch01_505">Routing helpers and their routes </title>
        <tgroup id="ch01_506">
          <thead id="ch01_507">
          <row id="ch01_508">
            <entry id="ch01_509"><para id="ch01_510">Helper</para></entry>
            <entry id="ch01_511"><para id="ch01_512">Route</para></entry>
          </row>
          </thead>
          <tbody id="ch01_513">
          <row id="ch01_514">
            <entry id="ch01_515"><para id="ch01_516"><code id="ch01_517">purchases_path</code></para></entry>
            <entry id="ch01_518"><para id="ch01_519"><code id="ch01_520">/purchases</code></para></entry>
          </row>

          <row id="ch01_521">
            <entry id="ch01_522"><para id="ch01_523"><code id="ch01_524">new_purchase_path</code></para></entry>
            <entry id="ch01_525"><para id="ch01_526"><code id="ch01_527">/purchases/new</code></para></entry>
          </row>

          <row id="ch01_528">
            <entry id="ch01_529"><para id="ch01_530"><code id="ch01_531">edit_purchase_path</code></para></entry>
            <entry id="ch01_532"><para id="ch01_533"><code id="ch01_534">/purchases/:id/edit</code></para></entry>
          </row>

          <row id="ch01_535">
            <entry id="ch01_536"><para id="ch01_537"><code id="ch01_538">purchase_path</code></para></entry>
            <entry id="ch01_539"><para id="ch01_540"><code id="ch01_541">/purchases/:id</code></para></entry>
          </row>
          </tbody>
        </tgroup>
      </table>
      
      <para id="ch01_542">
        In the above table, where there's <code id="ch01_543">:id</code> it can be substituted for the id of a record. Each routing helper has an alternative version which will give you the full URL to the resource. Simply use the <code id="ch01_668">_url</code> extension rather than <code id="ch01_669">_path</code> and you'll get a URL such as <code id="ch01_670">http://localhost:3000/purchases</code> for <code id="ch01_671">purchases_url</code>. 
      </para>
      
      <para id="ch01_544">
        From this table, two of these routes will act differently depending on how they're requested. The first route, <code id="ch01_545">/purchases</code> will take us to the <code id="ch01_546">index</code> action of <classname id="ch01_547">PurchasesController</classname> if we do a GET request. GET requests are the standard type of requests for web browsers, and this is the first request we did to this application. However, if we do a POST request to this route it will go to the <code id="ch01_548">create</code> action of the controller. This is the case when we submit the form from the <code id="ch01_549">new</code> view. Let's go to <code id="ch01_550">http://localhost:3000/purchases/new</code> now and look at the source of the page. We should see the beginning tag for our form looking like Listing 1.x.
      </para>
      
      <example id="ch01_551">
        <title id="ch01_552">The HTML source of app/views/purchases/new.html.erb</title>
        <programlisting>
<![CDATA[<form action="/purchases" class="new_purchase" id="new_purchase" method="post">]]>
        </programlisting>
      </example>
      
      <indexterm id="ch01_901">
        <primary id="ch01_902">form tag</primary>
      </indexterm>
      
      <para id="ch01_554">
        The two attributes to take note of here are the <code id="ch01_555">action</code> and <code id="ch01_556">method</code> attributes. The <code id="ch01_557">action</code> dictates the route to where this form goes and the <code id="ch01_558">method</code> tells the form what kind of HTTP request to make. 
      </para>
      
      <para id="ch01_559">
        How'd this tag get rendered in the first place? Well, as we saw before, the <filename id="ch01_560">app/views/purchases/new.html.erb</filename> template uses the form partial<indexterm id="ch01_903">
          <primary id="ch01_904">form_partial</primary></indexterm> from <filename id="ch01_561">app/views/purchases/_form.html.erb</filename> which contains this as the first line:
      </para>
      
      <informalexample id="ch01_562">
        <programlisting>
<![CDATA[<%= form_for(@purchase) do |f| %>]]>
        </programlisting>
      </informalexample>
      
      <para id="ch01_564">
        It's this one simple line that will generate that form tag. When we look at the <code id="ch01_565">edit</code> action shortly we'll see that the output of this tag is different, and we'll see why. 
      </para>
      
      <para id="ch01_566">
        The other route that will respond differently is the <code id="ch01_567">/purchases/{id}</code> route which acts in one of three ways. The first of these three ways we've seen: it's the <code id="ch01_568">show</code> action which we're redirected to (a GET request) after we create a purchase. The second of the three ways is when we edit  update a record, which we'll look at now.
      </para>
    </section>
    
    <section id="ch01_569">
      <title id="ch01_570">Updating</title>
      
      <para id="ch01_581">
        Let's change the cost of our "foo" purchase now. Perhaps it only cost 10. To do this, let's go back to http://localhost:3000/purchases and click on the "Edit" link next to our foo record. We should now see a page that looks similar to the <code id="ch01_582">new</code> page, shown in Figure 1.x.
      </para>
      
      <figure id="ch01_583">
        <title id="ch01_584">Editing a purchase</title>
        <mediaobject id="ch01_585">
          <imageobject id="ch01_586">
            <imagedata fileref="ch01/purchases_edit.png" id="ch01_587"/>
          </imageobject>
        </mediaobject>
      </figure>
      
      <para id="ch01_588">
        The reason this page looks similar is because it re-uses the partial we used in the <code id="ch01_589">new</code> action. Such is the power of partials, that we're able to use the same code for two different requests to our application. The template for this action can be seen in Listing 1.x.
      </para>
      
      <example id="ch01_590">
        <title id="ch01_591">app/views/purchases/edit.html.erb</title>
        <programlisting>
<![CDATA[<h1>Editing purchase</h1>

<%= render 'form' %>

<%= link_to 'Show', @purchase %> |
<%= link_to 'Back', purchases_path %>]]>
        </programlisting>
      </example>
      
      <para id="ch01_593">
        However for this action we're working with a pre-existing object, rather than a new object, which we used in <code id="ch01_594">new</code>. This pre-existing object is found by the <code id="ch01_595">edit</code> action in <classname id="ch01_596">PurchasesController</classname>, shown in Listing 1.x.
      </para>
      
      <example id="ch01_597">
        <title id="ch01_598">app/controllers/purchases_controller.rb</title>
        <programlisting>
# GET /purchases/1/edit
def edit
  @purchase = Purchase.find(params[:id])
  ...
end
        </programlisting>
      </example>
      
      <para id="ch01_600">
        The code to find the <code id="ch01_601">@purchase</code> object here is identical to what we've seen before in the <code id="ch01_602">show</code> action.
      </para>
      
      <para id="ch01_908">
        Back in the view for a moment, at the bottom of it we can see two uses of <code id="ch01_909">link_to</code>. The first creates a "Show" link, linking to the <code id="ch01_910">@purchase</code> object which is set up in the <code id="ch01_911">edit</code> action of our controller. Clicking this link would take us to <code id="ch01_912">purchase_path(@purchase)</code> or <uri id="ch01_913">/purchases/:id</uri>. Rails will figure out where the link needs to go based on the class of the object. Using this syntax, it will attempt to call the <code id="ch01_914">purchase_path</code> method because the object has a class of <classname id="ch01_915">Purchase</classname> and will pass the object along to that call, generating the URL.<footnote id="ch01_916"><para id="ch01_917">This syntax is exceptionally handy if we've got an object that we're not sure of the type but still want to generate a link for it. For example, if we had a different kind of object called "Order" and this was used instead, it would use <code id="ch01_918">order_path</code> rather than <code id="ch01_919">purchase_path</code>.</para></footnote>
      </para>
      
      <note id="ch01_920">
        <title id="ch01_921">In the beginning...</title>
        <para id="ch01_922">
          <internalnote id="ch01_923">Sidebar-ize</internalnote>
          In really early versions of Rails, we had to generate links like this:
        </para>
      
        <para id="ch01_924">
          <informalexample id="ch01_925">
            <programlisting>
link_to "Back", { :controller =&gt; "purchases", 
                  :action =&gt; "show",
                  :id =&gt; @purchase.id }
            </programlisting>
          </informalexample>
        </para>
        
        <para id="ch01_927">
          This hash would then be interpreted and matched to a route, like <uri id="ch01_928">/purchases/1</uri>. We can still use it today in Rails 3 if we wish, but it's not best practice. A little shorter:
        </para>
      
        <para id="ch01_929">
          <informalexample id="ch01_930">
            <programlisting>
link_to "Back", "/purchases/#{@purchase.id}"
            </programlisting>
          </informalexample>
        </para>
        
        <para id="ch01_932">
          These days, this is best:
        </para>
        
        <para id="ch01_933">
          <informalexample id="ch01_934">
            <programlisting>
link_to "Back", @purchase
            </programlisting>
          </informalexample>
        </para>
        
        <para id="ch01_936">
          By using the routing helpers introduced in Rails 2 and still available in Rails 3.1, we are able to have much shorter <code id="ch01_937">link_to</code> calls in our application increasing the readability of the code throughout.
        </para>
      </note>
      
      
      <para id="ch01_938">
        The second use of <code id="ch01_939">link_to</code> in this view generates a "Back" link which uses the routing helper <code id="ch01_940">purchases_path</code>. It cannot use an object here because it doesn't make sense to, calling <code id="ch01_941">purchases_path</code> is the easy way to go back to the index action here.
      </para>
      
      <para id="ch01_603">
        Let's try filling in this form now, for example changing our cost from 100 to 10, and pressing "Update Purchase". We will now see the <code id="ch01_604">show</code> page, but with a different message, shown in Figure 1.x.
      </para>
      
      <figure id="ch01_605">
         <title id="ch01_606">Viewing an updated purchase</title>
         <mediaobject id="ch01_607">
           <imageobject id="ch01_608">
             <imagedata fileref="ch01/updated_purchase.png" id="ch01_609"/>
           </imageobject>
         </mediaobject>
       </figure>
       
       <para id="ch01_610">
         So we pressed "Update Purchase" and we wound up back at the <code id="ch01_611">show</code> page. How did this happen? Well, let's press the back button on our browser and view the source of this page, specifically the <code id="ch01_612">form</code> tag and the tags directly underneath, shown in Listing 1.x.
       </para>
       
       <example id="ch01_613">
         <title id="ch01_614">The HTML source of app/views/purchases/edit.html.erb</title>
         <programlisting>
form action="/purchases/2" class="edit_purchase" id="edit_purchase_2" method="post"
   div style="margin:0;padding:0;display:inline"
     input name="_method" type="hidden" value="put" / <co id="ch01_615_1"/>
   /div
  ...
         </programlisting>
         <calloutlist id="ch01_745">
           <callout arearefs="ch01_615_1 ch01_615_1a" id="ch01_746">The method input tag</callout>
         </calloutlist>
       </example>
       
       <para id="ch01_616">
         This <code id="ch01_617">form</code>'s <code id="ch01_618">action</code> points at <code id="ch01_619">/purchases/2</code> which we know to be the route to the <code id="ch01_620">show</code> action in <classname id="ch01_621">PurchasesController</classname>. However, we should also take note of two other things. The <code id="ch01_622">method</code> attribute of this form is a <code id="ch01_623">post</code>, but there's also the <code id="ch01_624">input</code> tag underneath.
         
       </para>
       
       <para id="ch01_625">
          The <code id="ch01_747">input</code> tag here <co id="ch01_615_1a"/> passes through the <code id="ch01_626">_method</code> parameter with the value set to "put". Rails catches this parameter and turns this request from a POST, into a PUT. This is the second (of three)  way which the <code id="ch01_627">/purchases/{id}</code> responds based on the method. By making a PUT request to this route we're taken to the <code id="ch01_628">update</code> action in <classname id="ch01_629">PurchasesController</classname>. Let's take a look at this now, it's shown in Listing 1.x.
       </para>
       
       <example id="ch01_630">
         <title id="ch01_631">app/controllers/purchases_controller.rb</title>
         <programlisting>
<![CDATA[def update
  @purchase = Purchase.find(params[:id])

  respond_to do |format|
    if @purchase.update_attributes(params[:purchase])
      format.html { redirect_to(@purchase, 
                       :notice => 'Purchase was successfully updated.') }
      format.xml  { head :ok }
    else
      format.html { render :action => "edit" }
      format.xml  { render :xml => @purchase.errors, 
                           :status => :unprocessable_entity }
    end
  end
end]]>
         </programlisting>
       </example>
       
       <para id="ch01_633">
         Just like in the <code id="ch01_634">show</code> and <code id="ch01_635">edit</code> actions, we fetch the object first by using the <code id="ch01_636">find</code> method. The parameters from the form are sent through in the same fashion as they were in the <code id="ch01_637">create</code> action -- coming through as <code id="ch01_638">params[:purchase]</code>. Rather than instantiating a new object by using the <code id="ch01_639">new</code> class method, we use <code id="ch01_640">update_attributes</code><indexterm id="ch01_944">
           <primary id="ch01_945">update_attributes, ActiveRecord::Base</primary></indexterm> on the <code id="ch01_641">@purchase</code> object. This will do what it says on the tin: update the attributes. What it doesn't say on the tin though is that it'll validate the attributes and then if it's valid, save the record and return <code id="ch01_642">true</code>. If it's not valid, then it'll return <code id="ch01_643">false</code>.
       </para>
       
       <para id="ch01_644">
         When <code id="ch01_645">update_attributes</code> returns <code id="ch01_646">true</code> we're redirected back to the <code id="ch01_647">show</code> action for this particular purchase by using <code id="ch01_648">redirect_to</code>.
        </para>
        
        <para id="ch01_649">
          If it returns <code id="ch01_650">false</code> then we're shown the <code id="ch01_651">edit</code> action's template again, just like back in the <code id="ch01_652">create</code> action where we were shown the <code id="ch01_653">new</code> template again. This works in the same fashion and will display errors if we enter something wrong. Let's try editing a purchase and setting the name to blank and then pressing "Update Purchase". It should error exactly like the <code id="ch01_654">create</code> method did, as shown in Figure 1.x.
       </para>
       
       <figure id="ch01_655">
         <title id="ch01_656">Update fails!</title>
         <mediaobject id="ch01_657">
           <imageobject id="ch01_658">
             <imagedata fileref="ch01/update_purchase_fail.png" id="ch01_659"/>
           </imageobject>
         </mediaobject>
       </figure>
       
       <para id="ch01_660">
         As we can see by this example, the validations we've defined in our <classname id="ch01_661">Purchase</classname> model take effect for both the creation and updating of records automatically.
       </para>
       
       <para id="ch01_662">
         Now what would happen if you wanted to rather than update a purchase, to delete it? Well, that's built-in to the scaffold too.
       </para>
    </section>
    
    <section id="ch01_663">
      <title id="ch01_664">Deleting</title>
      <para id="ch01_665">
        In Rails, delete is given a much more forceful name of "destroy". This is another sensible name because to destroy a record is to "put an end to the existence of"<footnote id="ch01_672">Mac OS X dictionary</footnote>. Once this record's gone, it's gone baby, gone.
      </para>
      
      <para id="ch01_673">
        We can destroy a record by going to http://localhost:3000/purchases and clicking the "Destroy" link shown in Listing 1.x and then clicking "OK" on the confirmation box that pops up.
      </para>
      
      <figure id="ch01_674">
        <title id="ch01_675">Destroy!</title>
        <mediaobject id="ch01_676">
          <imageobject id="ch01_677">
            <imagedata fileref="ch01/purchase_destroy.png" id="ch01_678"/>
          </imageobject>
        </mediaobject>
      </figure>
      
      <para id="ch01_679">
        When that record's destroyed we're taken back to the "Listing purchases" page. We'll see that the record no longer exists. We should now only have one record as shown in Figure 1.x.
      </para>
      
      <figure id="ch01_680">
        <title id="ch01_681">Last record standing</title>
        <mediaobject id="ch01_682">
          <imageobject id="ch01_683">
            <imagedata fileref="ch01/purchase_listing.png" id="ch01_684"/>
          </imageobject>
        </mediaobject>
      </figure>
      
      <para id="ch01_685">
        So how does all of this work? Let's look at the <code id="ch01_686">index</code> template to understand, specifically the part that's used to list the purchases. It's shown in Listing 1.x.
      </para>
      
      <example id="ch01_687">
        <title id="ch01_688">app/views/purchases/index.html.erb</title>
        <programlisting>
<![CDATA[

<% @purchases.each do |purchase| %>
  <tr>
    <td><%= purchase.name %></td>
    <td><%= purchase.cost %></td>
    <td><%= link_to 'Show', purchase %></td>
    <td><%= link_to 'Edit', edit_purchase_path(purchase) %></td>
    <td><%= link_to 'Destroy', purchase, :confirm => 'Are you sure?', 
                                         :method => :delete %></td>
  </tr>
<% end %>
</table>

<br />

<%= link_to 'New Purchase', new_purchase_path %>]]>
        </programlisting>
      </example>
      
      <para id="ch01_690">
        In this template, <code id="ch01_691">@purchases</code> is a collection of all the objects from the <classname id="ch01_692">Purchase</classname> model and <code id="ch01_693">each</code> is used to iterate over each, setting <code id="ch01_694">purchase</code> as the variable used in this block.
      </para>
      
      <para id="ch01_695">
        In here the methods <code id="ch01_696">name</code> and <code id="ch01_697">cost</code> are the same methods used in <filename id="ch01_698">app/views/purchases/show.html.erb</filename> to display the values for the fields. After these, we see the three uses of <code id="ch01_699">link_to</code>.
      </para>
      
      <para id="ch01_700">
        The first <code id="ch01_701">link_to</code> passes in the <code id="ch01_702">purchase</code> object, which will link to the <code id="ch01_703">show</code> action of <classname id="ch01_704">PurchasesController</classname> by using a route such as <code id="ch01_705">/purchases/{id}</code>, where <code id="ch01_706">{id}</code> is the id for this <code id="ch01_707">purchase</code> object.
      </para>
      
      <para id="ch01_708">
        The second <code id="ch01_709">link_to</code> links to the <code id="ch01_710">edit</code> action using <code id="ch01_711">edit_purchase_path</code> and passes the <code id="ch01_712">purchase</code> object as the argument to this method. This routing helper will determine the path is <code id="ch01_713">/purchases/{id}/edit</code>. 
      </para>
      
      <para id="ch01_714">
        The third <code id="ch01_715">link_to</code> links seemingly to the <code id="ch01_716">purchase</code> object exactly like the first, but it doesn't go there. The <code id="ch01_717">:method</code> option on the end of this route specifies the method of <code id="ch01_718">:delete</code>, which is the third and final way the <code id="ch01_719">/purchases/{id}</code> route can be used. By specifying <code id="ch01_720">:delete</code> as the method of this <code id="ch01_721">link_to</code>, Rails will interpret this request and take us to the <code id="ch01_722">destroy</code> action in the <classname id="ch01_723">PurchasesController</classname>. This action is shown in Listing 1.x.
      </para>
      
      <example id="ch01_724">
        <title id="ch01_725">app/controllers/purchases_controller.rb</title>
        <programlisting>
def destroy
  @purchase = Purchase.find(params[:id])
  @purchase.destroy

  respond_to do |format|
    format.html { redirect_to(purchases_url) }
    format.xml  { head :ok }
  end
end
        </programlisting>
      </example>
      
      <para id="ch01_727">
        Just like in the <code id="ch01_728">show</code>, <code id="ch01_729">edit</code> and <code id="ch01_730">update</code> actions we've looked at before, this action also finds the <code id="ch01_731">@purchase</code> object by using <code id="ch01_732">Purchase.find</code> and then destroys the record by calling <code id="ch01_733">destroy</code><indexterm id="ch01_948"><primary id="ch01_949">destroy, ActiveRecord::Base</primary></indexterm> on it, which permanently deletes the record. After that's done it uses <code id="ch01_734">redirect_to</code> to take us to the <code id="ch01_735">purchases_url</code>, which is the route helper defined to take us to <code id="ch01_736">http://localhost:3000/purchases</code> URL. Note that this action uses the <code id="ch01_737">purchases_url</code> method rather than <code id="ch01_738">purchases_path</code> which will generate a full URL back to the purchases listing, such as <uri id="ch01_950">http://localhost:3000/purchases/1</uri>.
      </para>
      
      <para id="ch01_739">
        That wraps up our application run-through!
      </para>
    </section>
  </section>

  <section id="ch01_229">
    <title id="ch01_230">Summary</title>
    
    <para id="ch01_231">
      In this chapter we have learned what Rails is and how to get an application started with it, the absolute bare, bare, <emphasis id="ch01_232">bare</emphasis> essentials of a Rails application. But look at how fast we got going! It was only a few simple commands and an entire two lines of our own code in order to get the bones of a Rails application going. From this basic skeleton we can keep adding on bits and pieces in order to develop our application and all the while we get things "for free" from Rails. We don't have to code the logic of what happens when Rails receives a request, or what query we have to execute on our database to insert a record, it does it for us.
    </para>

    <para id="ch01_233">
      We also saw that some big name players -- such as Twitter and GitHub -- use Ruby on Rails. This clearly gives a positive answer to the "is Rails ready?" question: Yes, it very much is. There's a wide choice of companies that have built successful websites on the Rails framework, and a lot more to come.
    </para>

    <para id="ch01_234">
      Still wondering if Ruby on Rails is right for you? Ask around. You'll hear a lot of people singing its praises. The Ruby on Rails community is passionate about not only Rails, but also community building. Events, conferences, user group meetings and even camps are held all around the world for Rails. Attend these and discuss Ruby on Rails with the people who know about it. If you're unable to, or if you are shy, or for any other reason, there's the IRC channel on Freenode <emphasis id="ch01_235">#rubyonrails</emphasis>, the mailing list <emphasis id="ch01_236">rubyonrails-talk</emphasis> on Google Groups, not to mention Stack Overflow and a multitude of other areas on the internet where you can discuss with experienced people what they think of Rails. Don't let this book be the only source for your knowledge. There's a whole world out there! No book could cover all of that! We do try, however.
    </para>

    <para id="ch01_237">
      The best way to answer the "What is Rails?" question is to experience it for yourself. This book and your own exploration will answer that question, given a little time; nothing happens overnight.
    </para>

    <para id="ch01_238">
      When we added validations to our application earlier, we manually tested that they were working. While this may seem like a good idea for now, when the application grows beyond something more than a couple of pages, it becomes cumbersome to manually test them. Wouldn't it be nice if we had some automated way of testing our application? Something to ensure that all the individual parts work always? Something to provide the peace of mind that you crave when you develop anything? You want to be sure that it's continuously working with the most minimal effort possible, right?
    </para>

    <para id="ch01_239">
      Well, Ruby on Rails does that too. There are several testing frameworks for Ruby and Ruby on Rails and next up we will look at three of them: Test::Unit, RSpec and Cucumber.
    </para>
  </section>

  <section>
    <title>Regression tests</title>

    <example id='regression_1'>
      <title>omg</tilte>
      <programlisting>
validates :title, :presence =&gt; true
validates :description, :presence =&gt; true
      </programlisting>
    </example>
  </section>
</chapter>
